"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
const readers_1 = require("./readers");
exports.createParserContext = (buffer, offset = 0) => (Object.assign(Object.assign({}, common_1.createContext(buffer)), { offset, values: {} }));
exports.parse = (fn) => (buffer, offset = 0) => fn(exports.createParserContext(buffer, offset)).values;
exports.applyValue = ([value, length]) => (prop) => (context) => (Object.assign(Object.assign({}, context), { offset: context.offset + length, values: Object.assign(Object.assign({}, context.values), { [prop]: value }) }));
exports.applyArrayValue = (prop) => (parentContext) => (context) => (Object.assign(Object.assign({}, context), { values: Object.assign(Object.assign({}, parentContext.values), { [prop]: typeof parentContext.values[prop] === 'undefined'
            || !Array.isArray(parentContext.values[prop])
            ? [context.values]
            : [...parentContext.values[prop], context.values] }) }));
exports.readValue = (fn) => (prop) => (context) => exports.applyValue(fn(context))(prop)(context);
exports.bytes = (prop) => (length) => exports.readValue(readers_1.readBytes(length))(prop);
exports.int8 = exports.readValue(readers_1.readInt8);
exports.uint8 = exports.readValue(readers_1.readUint8);
exports.int16 = (endian) => exports.readValue(readers_1.readInt16(endian));
exports.int16Le = exports.int16(common_1.Endian.LITTLE);
exports.int16Be = exports.int16(common_1.Endian.BIG);
exports.uint16 = (endian) => exports.readValue(readers_1.readUint16(endian));
exports.uit16Le = exports.uint16(common_1.Endian.LITTLE);
exports.uit16Be = exports.uint16(common_1.Endian.BIG);
exports.int32 = (endian) => exports.readValue(readers_1.readInt32(endian));
exports.int32Le = exports.int32(common_1.Endian.LITTLE);
exports.int32Be = exports.int32(common_1.Endian.BIG);
exports.uint32 = (endian) => exports.readValue(readers_1.readUint32(endian));
exports.uint32Le = exports.uint32(common_1.Endian.LITTLE);
exports.uint32Be = exports.uint32(common_1.Endian.BIG);
exports.bigInt64 = (endian) => exports.readValue(readers_1.readBigInt64(endian));
exports.bigInt64Le = exports.bigInt64(common_1.Endian.LITTLE);
exports.bigInt64Be = exports.bigInt64(common_1.Endian.BIG);
exports.bigUint64 = (endian) => exports.readValue(readers_1.readBigUint64(endian));
exports.bigUint64Le = exports.bigUint64(common_1.Endian.LITTLE);
exports.bigUint64Be = exports.bigUint64(common_1.Endian.BIG);
exports.float32 = (endian) => exports.readValue(readers_1.readFloat32(endian));
exports.float32Le = exports.float32(common_1.Endian.LITTLE);
exports.float32Be = exports.float32(common_1.Endian.BIG);
exports.float64 = (endian) => exports.readValue(readers_1.readFloat64(endian));
exports.float64Le = exports.float64(common_1.Endian.LITTLE);
exports.float64Be = exports.float64(common_1.Endian.BIG);
exports.fixedString = (encoding) => (length) => exports.readValue(readers_1.readFixedString(encoding)(length));
exports.fixedAsciiString = exports.fixedString('ascii');
exports.fixedUtf8String = exports.fixedString('utf8');
exports.skip = (length) => (context) => (Object.assign(Object.assign({}, context), { offset: context.offset + length }));
exports.sequence = (...fns) => (context) => fns.reduce((ctx, fn) => fn(ctx), context);
exports.push = (fn) => (prop) => (ctx) => common_1.apply(exports.applyArrayValue(prop)(ctx), fn(Object.assign(Object.assign({}, ctx), { values: {} })));
exports.repeat = (length) => (fn) => (prop) => exports.sequence(...Array.from({ length }, () => exports.push(fn)(prop)));
exports.repeatToEnd = (fn) => (prop) => exports.sequence(exports.push(fn)(prop), ctx => ctx.offset < ctx.buffer.byteLength ? exports.repeatToEnd(fn)(prop)(ctx) : ctx);
exports.clear = (context) => (Object.assign(Object.assign({}, context), { values: {} }));
exports.use = (handler) => (context) => handler(context.values)(context);
exports.when = (value) => (cases) => { var _a; return (_a = cases) === null || _a === void 0 ? void 0 : _a[value]; };
exports.log = (handler) => (context) => {
    console.log(handler(context));
    return context;
};
exports.logProp = (prop) => exports.log(ctx => `${prop}: ${ctx.values[prop]} [${ctx.offset}]`);
