import { Context, Endian } from './common';
import { ReadFunction, ValueLengthTuple } from './readers';
export interface ParserContext<T> extends Context {
    values: Partial<T>;
}
export declare type ParseFunction<T> = (context: ParserContext<T>) => ParserContext<T>;
export declare const createParserContext: <T>(buffer: ArrayBuffer, offset?: number) => ParserContext<T>;
export declare const parse: <T>(fn: ParseFunction<T>) => (buffer: ArrayBuffer, offset?: number) => Partial<T>;
export declare const applyValue: <T, K extends keyof T = keyof T>([value, length]: ValueLengthTuple<T[K]>) => (prop: K) => (context: ParserContext<T>) => ParserContext<T>;
export declare const applyArrayValue: <T, V = T>(prop: keyof T) => (parentContext: ParserContext<T>) => (context: ParserContext<V>) => ParserContext<T>;
export declare const readValue: (fn: ReadFunction<any>) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const bytes: <T>(prop: keyof T) => (length: number) => (context: ParserContext<T>) => ParserContext<T>;
export declare const int8: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const uint8: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const int16: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const int16Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const int16Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const uint16: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const uit16Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const uit16Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const int32: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const int32Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const int32Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const uint32: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const uint32Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const uint32Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const bigInt64: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const bigInt64Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const bigInt64Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const bigUint64: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const bigUint64Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const bigUint64Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const float32: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const float32Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const float32Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const float64: (endian: Endian) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const float64Le: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const float64Be: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const fixedString: (encoding: string) => (length: number) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const fixedAsciiString: (length: number) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const fixedUtf8String: (length: number) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const skip: <T>(length: number) => (context: ParserContext<T>) => ParserContext<T>;
export declare const sequence: <T>(...fns: ParseFunction<T>[]) => (context: ParserContext<T>) => ParserContext<T>;
export declare const push: <V>(fn: ParseFunction<V>) => <T>(prop: keyof T) => (ctx: ParserContext<T>) => ParserContext<T>;
export declare const repeat: (length: number) => <V>(fn: ParseFunction<V>) => <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
export declare const repeatToEnd: <V>(fn: ParseFunction<V>) => <T>(prop: keyof T) => ParseFunction<T>;
export declare const clear: <T>(context: ParserContext<T>) => ParserContext<T>;
export declare const use: <T>(handler: (values: T) => ParseFunction<T>) => (context: ParserContext<T>) => ParserContext<T>;
export declare const when: <V extends string | number | symbol>(value: V) => <T>(cases: { [K in V]: ParseFunction<any>; }) => ParseFunction<T> | undefined;
export declare const log: <T>(handler: (context: ParserContext<T>) => string) => (context: ParserContext<T>) => ParserContext<T>;
export declare const logProp: <T>(prop: keyof T) => (context: ParserContext<T>) => ParserContext<T>;
